load("@rules_foreign_cc//foreign_cc:configure.bzl", "configure_make")
load("@rules_foreign_cc//foreign_cc:meson.bzl", "meson")

PG_BINARIES = [
    "initdb",
    "postgres",
    "pg_config",
    "pg_isready",
]

# NOTE: including lib in out_data_dirs because even when it's
# out_lib_dir's default, it's not included in declared_outputs
OUT_DATA_DIRS = [
    "lib",
    "share",
]

BUILD_DATA = [
    "@m4//bin:m4",
    "@flex//bin:flex",
    "@bison//bin:bison",
    "@python_3_11//:python3",
]

TOOLCHAINS = [
    "@rules_m4//m4:current_m4_toolchain",
    "@rules_flex//flex:current_flex_toolchain",
    "@rules_bison//bison:current_bison_toolchain",
]

# NOTE:
# For env vars that have relative paths starting with 'external/'
# rules_foreign_cc makes them absolute prepending $$EXT_BUILD_ROOT$$
# automatically, see:
# https://github.com/bazel-contrib/rules_foreign_cc/blob/0.12.0/foreign_cc/private/make_env_vars.bzl#L123-L124
# https://github.com/bazel-contrib/rules_foreign_cc/blob/0.12.0/foreign_cc/private/cc_toolchain_util.bzl#L352
#
# HOWEVER! this seems to only apply to $(execpath ...) So, if you have an env
# variable (e.g. TEST = "external/foo/bar") or a Make variable from a toolchain
# (e.g. "$(TEST)") that resolves to "external/foo/bar" IT WON'T WORK without
# explicitly adding the $$EXT_BUILD_ROOT prefix.
ENV = dict(
    BISON = "$(execpath @bison//bin:bison)",
    FLEX = "$(execpath @flex//bin:flex)",
    # NOTE:
    # The flex binary from rules_flex doesn't have a macro processor defined at
    # compile time so flex will try to find the m4 binary using the M4 env
    # variable and if not set, it will just call `m4` and will let `execvp` to
    # resolve it using `PATH`.
    M4 = "$(execpath @m4//bin:m4)",
    PYTHON = "$(execpath @python_3_11//:python3)",
)

ENV_MESON = dict(
    # NOTE:
    # https://github.com/jmillikin/rules_bison/issues/17#issuecomment-2399677539
    #
    # I'm not sure who's responsible (Bazel or rules_foreign_cc) but
    # rules_foreign_cc meson is using a wrapper script that does some runfiles
    # initialization that ends up being wrong: it points to the Meson runfiles
    # dir when running tools from Meson and Bison can't find some of its data
    # files.
    #
    # Looking at the rules_foreign_cc wrapper script:
    # https://github.com/bazel-contrib/rules_foreign_cc/blob/0.12.0/foreign_cc/private/runnable_binary_wrapper.sh
    # I found that if the RUNFILES_DIR was set to the Bison runfiles dir, it
    # would use it. Now, this hack seems to "fix" it but IMHO it's very fragile
    # and it seems to work by sheer luck, probably because the rest of the
    # tools are not needing it. If another tool does, I think it would probably
    # fail...
    RUNFILES_DIR = "$(execpath @bison//bin:bison).runfiles/",
)

# NOTE:
# Postgres configure-make build uses env variables to find / override the tools
# but the Meson build uses find_program(get_option('<TOOL>'), ...) so we have
# to pass the tools as Meson options pointing them at the env variables.
MESON_TOOL_OPTIONS = dict(
    BISON = "$BISON",
    FLEX = "$FLEX",
    PYTHON = "$PYTHON",
)

VERSION = "16.0"

PG_SRC = "@pg_src--%s" % VERSION

# Postgres embeds the install paths via a generated pg_config.h that uses the
# prefix but the prefix is the install prefix **at build time**. Since we build
# in sandboxes and will be installing the binaries at a different path, we've
# added a patch that adds a new prefix_distro build option to set the prefix of
# the "final install path in the distro".
PREFIX_DISTRO = "/postgres"

configure_make(
    name = "cm",
    args = select({
        "@platforms//os:linux": ["-j$(nproc)"],
        "//conditions:default": [],
    }),
    build_data = BUILD_DATA,
    configure_in_place = True,
    configure_options = [
        "--disable-rpath",
        "--without-icu",
        "--without-readline",
        "--without-zlib",
    ],
    env = ENV,
    lib_source = PG_SRC,
    out_binaries = PG_BINARIES,
    out_data_dirs = OUT_DATA_DIRS,
    toolchains = TOOLCHAINS,
    visibility = ["//visibility:public"],
)

filegroup(
    name = "cm--logs",
    srcs = [":cm"],
    output_group = "Configure_logs",
)

meson(
    name = "meson",
    build_data = BUILD_DATA,
    env = ENV | ENV_MESON,
    lib_source = PG_SRC,
    options = {
        "icu": "disabled",
        "prefix_distro": "%s/%s" % (PREFIX_DISTRO, VERSION),
        "readline": "disabled",
        "rpath": "false",
        "zlib": "disabled",
    } | MESON_TOOL_OPTIONS,
    out_binaries = PG_BINARIES,
    out_data_dirs = OUT_DATA_DIRS,
    toolchains = TOOLCHAINS,
    visibility = ["//visibility:public"],
)

# NOTE:
# This target is useful for debugging. On failure, rules_foreign_cc does print
# the path to the compilation log and the wrapper scripts but it can also be
# useful to access these after a successful compilation (plus it gives a nicer
# path to access the logs and a simple way to access it, just bazel build it).
filegroup(
    name = "meson--logs",
    srcs = [":meson"],
    output_group = "Meson_logs",
)

alias(
    name = "postgres",
    actual = "meson",
)

alias(
    name = "logs",
    actual = "meson--logs",
)
