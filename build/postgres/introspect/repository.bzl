"""
Repository rule to create Postgres introspect repos.

These repos expose metadata about the Postgres build, such as all the generated
files. The metadata is extracted and generated from the Meson introspection
JSON files and the meson_options.txt file.

This metadata enables the creation of "slice" targets that expose specific
subsets of the build output (e.g. the files belonging to individual Postgres
contrib extensions).
"""

load("@download_archives//lib:index.bzl", Index = "index")
load("@starlark_utils//starlark:starlark.bzl", Starlark = "starlark")
load("//postgres/introspect/lib:meson.bzl", MesonIntrospect = "meson")
load("//postgres/introspect/lib:metadata.bzl", "FEATURES_TO_DEB_PKGS")

_BUILD = '''\
"""Generated by postgres/introspect. DO NOT EDIT."""

load("@bazel_skylib//:bzl_library.bzl", "bzl_library")

package(default_visibility = ["//visibility:public"])

exports_files([
    "defs.bzl",
])

bzl_library(
    name = "defs",
    srcs = ["defs.bzl"],
    deps = {deps},
)

alias(
    name = "{name}",
    actual = ":defs",
)
'''

_DEFS = '''\
"""Generated by postgres/introspect. DO NOT EDIT."""

{loads}

{assignments}
'''

_BUILD_PRIV = '''\
"""Generated by postgres/introspect. DO NOT EDIT."""

load("@bazel_skylib//:bzl_library.bzl", "bzl_library")

package(default_visibility = ["//{pg_version}/{option_set}:__pkg__"])

exports_files([
    "meson_options.bzl",
])

bzl_library(
    name = "meson_options",
    srcs = ["meson_options.bzl"],
)
'''

# helpers to get files from a download_archives PG repo

def _pgsrc_subpath(pg_version = None, pg_source = None):
    def f(subpath):
        for prefix in (pg_source, pg_version):
            if prefix != None:
                subpath = "%s/%s" % (prefix, subpath.lstrip("/"))
        return subpath

    return f

def _rctx_read(rctx, pg_version = None, pg_source = None):
    def f(subpath):
        """
        Read file in subpath relative to PG src directory.
        """
        pgsrc_repo = rctx.path(Label(rctx.attr.pg_src)).dirname
        pgsrc_subpath = _pgsrc_subpath(pg_version, pg_source)

        return rctx.read(pgsrc_repo.get_child(pgsrc_subpath(subpath)))

    return f

def _rctx_file(rctx, pg_version = None, option_set = None, executable = False):
    def f(path, content):
        """
        Create file in a repo subpath relative to PG version/source directory.
        """
        pgsrc_subpath = _pgsrc_subpath(pg_version, option_set)

        rctx.file(pgsrc_subpath(path), content, executable = executable)

    return f

def _write_subrepo(rctx, pg_version, option_set, introspection, meson_options_bzl):
    rctx_file = _rctx_file(rctx, pg_version, option_set)

    rctx_file(
        "private/meson_options.bzl",
        meson_options_bzl,
    )
    rctx_file(
        "private/BUILD.bazel",
        _BUILD_PRIV.format(
            pg_version = pg_version,
            option_set = option_set,
        ),
    )

    dep = "//{pg_version}/{option_set}/private:meson_options".format(
        pg_version = pg_version,
        option_set = option_set,
    )

    deps = Starlark.igen([dep], indent_count = 1)

    loads = Starlark.load_("%s.bzl" % dep, "OPTIONS")

    assignments = Starlark.assignments(
        dict(
            FEATURES_TO_DEB_PKGS = Starlark.igen(FEATURES_TO_DEB_PKGS),
            INTROSPECTION = Starlark.igen(introspection),
            MESON_OPTIONS = "OPTIONS",
        ),
        inline = False,
        quote_values = False,
    )

    rctx_file("defs.bzl", _DEFS.format(loads = loads, assignments = assignments))
    rctx_file("BUILD.bazel", _BUILD.format(name = option_set, deps = deps))

def _write_root(rctx, name, deps_, loads_, introspections, meson_options):
    rctx_file = _rctx_file(rctx)

    loads = "\n".join([Starlark.load_(*ll[0], **ll[1]) for ll in loads_])

    assignments = Starlark.assignments(
        dict(
            INTROSPECTIONS = Starlark.igen(
                introspections,
                quote_keys = False,
                quote_strings = False,
            ),
            MESON_OPTIONS = Starlark.igen(
                meson_options,
                quote_keys = False,
                quote_strings = False,
            ),
        ),
        inline = False,
        quote_values = False,
    )

    deps = Starlark.igen(deps_, indent_count = 1)

    rctx_file("defs.bzl", _DEFS.format(loads = loads, assignments = assignments))
    rctx_file("BUILD.bazel", _BUILD.format(name = name, deps = deps))

def _make_sources(rctx):
    pgsrc_read = _rctx_read(rctx)

    index = Index.new(rctx.attr.name, pgsrc_read("index.json"))

    introspect_meta = index.metadata.get("introspect", {})

    sources = {}

    for repos in index.repos.values():
        if not repos:
            continue

        # all sources are mirrors and have the exact same files per version
        pg_version, pg_source = repos[0].version, repos[0].source
        pgsrc_read = _rctx_read(rctx, pg_version, pg_source)

        introspect_jsons = introspect_meta.get(pg_version, {})

        if not introspect_jsons:
            msg = "WARNING: Missing introspect JSONs for PG %s"

            # buildifier: disable=print
            print(msg % pg_version)
            continue

        for option_set, introspect_label in introspect_jsons.items():
            if not introspect_label:
                msg = "WARNING: Missing introspect JSON for PG %s~%s"

                # buildifier: disable=print
                print(msg % (pg_version, option_set))
                continue

            introspect_json = json.decode(rctx.read(Label(introspect_label)))

            contrib_names = MesonIntrospect.get_contrib_names(introspect_json)

            contrib_features = {
                contrib_name: MesonIntrospect.get_contrib_features(
                    contrib_name,
                    pgsrc_read("contrib/%s/meson.build" % contrib_name),
                )
                for contrib_name in contrib_names
            }

            # NOTE: we want to fail if there's some unknown features or missing
            # paths when we are introspecting the 'full' PG build
            fail_on_unknown_or_empty = option_set == "full"

            MesonIntrospect.validate_contrib_features(
                contrib_features,
                fail_on_unknown_or_empty,
            )

            installed_paths = MesonIntrospect.get_installed_paths(
                introspect_json,
                rctx.os.arch,
            )

            contrib_paths = {
                contrib_name: MesonIntrospect.get_contrib_installed_paths(
                    installed_paths,
                    contrib_name,
                    pg_version,
                    rctx.os.arch,
                )
                for contrib_name in contrib_names
            }
            MesonIntrospect.validate_contrib_paths(
                contrib_paths,
                contrib_names,
                fail_on_unknown_or_empty,
            )

            contrib = {
                contrib_name: {
                    "features": contrib_features[contrib_name],
                    "paths": contrib_paths[contrib_name],
                }
                for contrib_name in contrib_names
            }

            introspection = {
                "contrib": contrib,
                "postgres": {
                    "paths": MesonIntrospect.get_postgres_installed_paths(
                        installed_paths,
                    ),
                },
            }

            meson_options_bzl = MesonIntrospect.meson_options_bzl(
                pgsrc_read("meson_options.txt"),
            )

            sources[(pg_version, option_set)] = (
                introspection,
                meson_options_bzl,
            )

    return sources

def _repo_impl(rctx):
    sources = _make_sources(rctx)

    introspections = {}
    meson_options = {}
    loads = []

    deps = []
    for key, data in sources.items():
        pg_version, option_set = key
        introspection, meson_options_bzl = data

        _write_subrepo(rctx, pg_version, option_set, introspection, meson_options_bzl)

        key_load = "%s_%s" % (pg_version.replace(".", "_"), option_set.upper())

        introspections[key] = "INTROSPECTION_PG_%s" % key_load
        meson_options[key] = "MESON_OPTIONS_PG_%s" % key_load

        defs = "//%s/%s:defs" % (pg_version, option_set)

        deps.append(defs)

        load_args = ["%s.bzl" % defs]
        load_args = ["//%s/%s:defs.bzl" % (pg_version, option_set)]
        load_kwargs = {
            introspections[key]: "INTROSPECTION",
            meson_options[key]: "MESON_OPTIONS",
        }
        loads.append((load_args, load_kwargs))

    _write_root(rctx, rctx.name, deps, loads, introspections, meson_options)

repo_attrs = {
    "pg_src": attr.label(
        doc = "Label of the PG src repo",
        allow_single_file = True,
        mandatory = True,
    ),
}

repo_doc = """
Repository rule to create Postgres introspect repos.
"""

repo = repository_rule(
    implementation = _repo_impl,
    attrs = repo_attrs,
    doc = repo_doc,
)
