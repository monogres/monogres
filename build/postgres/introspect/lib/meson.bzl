"""
Functions to parse and manipulate Meson's meson_option.txt files and JSON
introspect files
"""

load("@bazel_skylib//lib:paths.bzl", "paths")
load("@starlark_utils//starlark:starlark.bzl", Starlark = "starlark")
load("@version_utils//spec:spec.bzl", Spec = "spec")
load("@version_utils//version:version.bzl", Version = "version")
load("//utils:arch.bzl", "ARCH_MAP")
load(":metadata.bzl", "CONTRIB_INSTALLED_PATHS_OVERRIDE", "DEP_TO_FEATURE", "FEATURES_OVERRIDE", "FEATURES_TO_DEB_PKGS")

def _meson_options_bzl(meson_options_txt):
    return '''\
"""Generated by postgres/introspect. DO NOT EDIT."""

_FEATURES_TO_DEB_PKGS = {FEATURES_TO_DEB_PKGS}

_SKIP_FEATURES = [
    # these are "developer options"
    "dtrace", "tap_tests",

    # on top of those we want to exclude others, e.g.
    "bsd_auth",
]

# these are type "combo"
_FORCE_FEATURES = ["ssl", "uuid"]

OPTIONS = {{}}

def option(name, **kwargs):
    type_ = kwargs.get("type", "unknown")

    # HACK
    if name == name.upper():  # all caps
        category = "programs"
    elif (
        (type_ == "feature" and name not in _SKIP_FEATURES)
        or name in _FORCE_FEATURES
    ):
        category = "features"
    else:
        category = "options"

    if category not in OPTIONS:
        OPTIONS[category] = {{}}

    OPTIONS[category][name] = {{"name": name}} | kwargs

def _validate(features):
    # validate that we are not missing any option in _FEATURES_TO_DEB_PKGS
    unknown_options = [
        name
        for name in features
        if name not in _FEATURES_TO_DEB_PKGS
    ]

    if unknown_options:
        msg = "Unknown Meson options: %r. "
        msg += "You have to resolve the dependencies by hand first"
        fail(msg % unknown_options)

# HACK
# First, we convert the meson_options.txt file to valid Starlark.
# This way, when the file is evaluated, OPTIONS will be populated
# with the Meson options.

# --- meson_options.txt converted to valid Starlark ---
{meson_options_bzl}
# --- meson_options.txt converted to valid Starlark ---

_validate(OPTIONS["features"])
'''.format(
        FEATURES_TO_DEB_PKGS = Starlark.igen(FEATURES_TO_DEB_PKGS),
        meson_options_bzl = _meson_options_txt_to_bzl(meson_options_txt),
    )

def _meson_options_txt_to_bzl(meson_options_txt):
    """
    Convert meson_options.txt to valid Starlark.

    This is needed because, even though the generated introspect.json has all
    these options, the meson_options.txt file marks them as "type: feature" and
    somehow, Meson "drops" (changes) this in the introspect.json so there is no
    way to separate the features from the rest of the options.

    E.g.

    # meson_options.txt
    option('bonjour', type: 'feature', value: 'auto',
      description: 'Bonjour support')

    # introspect.json
    "buildoptions": [
        {
            "name": "bonjour",
            "value": "disabled",
            "section": "user",
            "machine": "any",
            "choices": [
                "enabled",
                "disabled",
                "auto"
            ],
            "type": "combo",
            "description": "Bonjour support"
        },
        (...)
    ]
    """
    lines = meson_options_txt.split("\n")
    new_lines = []

    for line in lines:
        if ":" not in line:
            new_lines.append(line)  # Keep lines unchanged if no match
        else:
            new_lines.append(line.replace(": ", " = "))

    return "\n".join(new_lines).replace("true", "True").replace("false", "False")

def _get_contrib_names(introspect_json):
    contrib_names = []

    for path in introspect_json["buildsystem_files"]:
        contrib = path.find("/contrib/")

        if contrib == -1:
            continue

        chunks = path[contrib + 1:].split("/", 3)

        if len(chunks) != 3 or chunks[-1] != "meson.build":
            # we ignore the contrib/meson.build and anything that's not
            # contrib/<SUBDIR>/meson.build
            continue

        contrib_names.append(chunks[1])

    return contrib_names

def _get_contrib_features(contrib_name, meson_build):
    """
    Get the features required to compile the contrib extension.

    The features are extracted by "parsing" the meson.build file. This is not
    perfect because dependency checks can have an else-branch, e.g.

        if zlib.found()
          pgcrypto_deps += zlib
          pgcrypto_regress += 'pgp-compression'
        else
          pgcrypto_regress += 'pgp-zlib-DISABLED'
        endif

    or the checks can actually be for something else (like basebackup_to_shell
    where the check is used to select tools during testing).

    In any case, most contrib extensions don't require any features, and we can
    always handle corner cases by hardcoding the features in FEATURES_OVERRIDE
    if necessary.
    """
    if contrib_name in FEATURES_OVERRIDE:
        return FEATURES_OVERRIDE[contrib_name]

    lines = meson_build.split("\n")

    deps = []

    for line in lines:
        dep = [
            chunk.replace(".found()", "").strip()
            for chunk in line.split(" ")
            if ".found()" in chunk
        ]

        if len(dep) > 1:
            fail("assert only one dep failed")

        if dep:
            deps.append(DEP_TO_FEATURE.get(dep[0], dep[0]))

    return (deps[0] if len(deps) == 1 else deps) if deps else None

def _validate_contrib_features(contrib_features, fail_on_unknown = False):
    unknown_contrib_features = {}
    for contrib, features in contrib_features.items():
        if features == None:
            continue

        if type(features) == "list":
            unknown = [f for f in features if f not in FEATURES_TO_DEB_PKGS]
        elif features not in FEATURES_TO_DEB_PKGS:
            unknown = features
        else:
            unknown = None

        if unknown:
            unknown_contrib_features[contrib] = unknown

    if unknown_contrib_features and fail_on_unknown:
        msg = "Unknown features: %r. " % unknown_contrib_features
        msg += "You have to resolve the dependencies by hand first"
        fail(msg)

def _get_objects_from_list(introspect_json, section, **attrs):
    return [
        obj
        for obj in introspect_json[section]
        if all([obj[attr] == value for attr, value in attrs.items()])
    ]

def _get_object_from_list(introspect_json, section, **attrs):
    objects = _get_objects_from_list(introspect_json, section, **attrs)

    if len(objects) > 1:
        fail("More than one object")

    return objects[0] if objects else None

def _get_buildoption(introspect_json, **attrs):
    return _get_object_from_list(introspect_json, "buildoptions", **attrs)

def _get_target(introspect_json, **attrs):
    return _get_object_from_list(introspect_json, "targets", **attrs)

def _relativize_build_path(introspect_json, path):
    # HACK to get the pg_src and build dir
    target_bin = _get_target(introspect_json, id = "bin@run")
    path_build_dir = paths.dirname(target_bin["filename"][0])
    path_pgsrc_dir = paths.dirname(target_bin["defined_in"])

    possible_prefixes = [
        path_build_dir,
        path_pgsrc_dir,
    ]

    for prefix in possible_prefixes:
        if path.startswith(prefix):
            return paths.relativize(path, prefix)

    if path[0] not in ("/", "<"):
        return path

    fail("Unable to match path prefix for path: %s" % path)

def _get_installed_paths(introspect_json, arch):
    installed_paths_ = introspect_json["installed"]

    prefix = _get_buildoption(introspect_json, name = "prefix")["value"]

    res = {
        _relativize_build_path(introspect_json, path_build): paths.relativize(path_installed, prefix)
        for path_build, path_installed in installed_paths_.items()
    }

    arch_ = ARCH_MAP.get(arch, arch)
    return {k.format(arch = arch_): v.format(arch = arch_) for k, v in res.items()}

def _get_contrib_installed_paths(installed_paths, contrib_name, pg_version, arch):
    contrib_paths = None

    if contrib_name in CONTRIB_INSTALLED_PATHS_OVERRIDE:
        overrides = CONTRIB_INSTALLED_PATHS_OVERRIDE[contrib_name]

        for cspec in overrides:
            spec = Spec.new(cspec, version_scheme = Version.SCHEME.PGVER)
            is_compatible = spec.match(pg_version)

            if is_compatible:
                contrib_paths = [
                    p.format(arch = ARCH_MAP.get(arch, arch))
                    for p in overrides[cspec]
                ]
                break

    if not contrib_paths:
        # NOTE:
        # deduping the installed_paths because some of them have different
        # build paths (e.g. share/tsearch_data has src/backend/tsearch/dicts
        # and src/backend/snowball/stopwords as build dirs)
        contrib_paths = {
            path_installed: path_build
            for path_build, path_installed in installed_paths.items()
            if path_build.startswith("contrib/%s" % contrib_name)
        }.keys()

    return sorted(contrib_paths)

def _get_postgres_installed_paths(installed_paths):
    rest_paths = {
        path_installed: path_build
        for path_build, path_installed in installed_paths.items()
        if not path_build.startswith("contrib/")
    }.keys()

    return sorted(rest_paths)

def _validate_contrib_paths(contrib_paths, contrib_names, fail_on_empty = False):
    if len(contrib_paths) != len(contrib_names):
        missing_contrib = [c for c in contrib_names if c not in contrib_paths]
        msg = "ERROR: These contrib names are not in 'installed': %r"
        fail(msg % missing_contrib)

    empty_paths = [
        contrib
        for contrib, paths in contrib_paths.items()
        if not paths
    ]

    if empty_paths and fail_on_empty:
        msg = "ERROR: Empty contrib paths, check for missing dependencies): %r"
        fail(msg % empty_paths)

meson = struct(
    get_installed_paths = _get_installed_paths,
    get_contrib_names = _get_contrib_names,
    get_contrib_features = _get_contrib_features,
    get_contrib_installed_paths = _get_contrib_installed_paths,
    get_postgres_installed_paths = _get_postgres_installed_paths,
    validate_contrib_features = _validate_contrib_features,
    validate_contrib_paths = _validate_contrib_paths,
    meson_options_bzl = _meson_options_bzl,
)
